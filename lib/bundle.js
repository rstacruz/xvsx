var marked = require('marked');
var hljs = require('highlight.js');
var merge = require('./merge').merge;

/*
 * Work
 */

if (!module.parent) {
  var files = process.argv.slice(2);
  try {
    var re = work(files);
    console.log(JSON.stringify(re));
  } catch (e) {
    console.warn("");
    console.warn("\033[31m error: \033[0m" + e.message);
    console.warn("");
    process.exit(16);
  }
}

/**
 * Works on given `files`, an array of files.
 * Returns a JSON that looks:
 *
 *     {
 *       outline: { ... },
 *       languages: {
 *         javascript: { ... },
 *         ruby: { ... }
 *       }
 *    }
 */

function work (files) {
  var re = {
    "": [
      "---",
      "--- This file is autogenerated.",
      "--- Please don't edit this file.",
      "---",
    ],
    outline: undefined,
    languages: {}
  };

  // step 1: build each
  var output, data, name;

  files.forEach(function (file) {
    data = require('fs').readFileSync(file, 'utf-8');
    name = require('path').basename(file, '.md');
    output = outlinify(data, { name: name, outline: re.outline });

    re.languages[name] = output;
  });

  re.outline = merge(values(re.languages));

  return re;
}

/**
 * Works on a markdown document `md`.  Returns a JSON object of the language
 * documentation.
 *
 * Optional: provide `outline` (a reference) to throw an error if a section
 * isn't found in the outline.
 *
 *     outlinify("### Variables\n\n    var x = 1;");
 */

function outlinify (md, ctx) {
  var tokens = marked.lexer(md);
  var outline = ctx && ctx.outline;
  var name = ctx && ctx.name;
  var re = {};
  var h2, h2text, h3;

  tokens.forEach(function (t) {
    // token.type == 'heading' | 'paragraph' | 'code' | 'list_start' | 'list_item_start' | 'list_item_end'
    // token.text == '...' (paragraph, heading)
    // token.lang == 'rb' (code)
    // token.depth == 1 | 2 | 3
    //

    /* h1 */
    if (t.type === 'heading' && t.depth === 1) {
      if (!name) name = t.text;
    }

    /* h2 */
    else if (t.type === 'heading' && t.depth === 2) {
      if (outline && !outline[t.text])
        throw new Error(name + ": h2 not found in outline: '"+t.text+"'");
      re[t.text] = {};
      h2text = t.text;
      h2 = re[t.text];
    } 

    /* h3 */
    else if (t.type === 'heading' && t.depth === 3) {
      if (!h2)
        throw new Error(name + ": h3 found without h2");

      if (outline && !outline[h2text][t.text])
        throw new Error(name + ": h3 not found in outline: '"+t.text+"' (in '"+h2text+"')");

      h2[t.text] = {};
      h3 = h2[t.text];
    }

    /* h3 > code */
    else if (t.type === 'code') {
      var html = hljs.highlight(name, t.text).value;
      h3.code = html;
    }

    /* h3 > text */
    else if (t.type === 'paragraph') {
      if (h3) {
        if (h3.text) {
          h3.text += "\n" + marked(t.text);
        } else {
          h3.text = marked(t.text);
        }
      }
    }
  });

  return re;
}

module.exports = {
  outlinify: outlinify,
  work: work
};

function values (obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

